Insert Strategies
	* Identity Output
	* Identity Select
	
Result Intercept Targets
	* DbType
	* MyColumn
	
Result Intercept Types
	* Alteration
	* Transformation

IResultIntercept
	* IInterceptTarget (e.g. Result Intercept Targets)
	* IInterceptor
	
Parameter Intercept Targets
	* Type
	
Parameter Intercept Types
	* Alteration
	* Transformation
	* Script
	
IParameterIntercept
	* IInterceptorTarget (e.g. Parameter Intercept Targets)
	* Interceptor
	* ReturnEmptyWhen Func<value, bool>
	
Accessor Commands
	* RegisterResultInterceptFor(DbType)
	* RegisterResultInterceptFor(MyColumn)
	* RegisterResultIntercept(IResultIntercept)
	* RegisterResultIntercepts(IEnumerable<IResultIntercept>)???  without this you would linq
	* RegisterParameterInterceptFor(Type)
	* RegisterParameterIntercept(IParameterIntercept)
	* RegisterParameterIntercepts(IEnumerable<IParameterIntercept>)???  without this you would linq
	* SpecifyInsertStrategyFor(MyTable, InsertStrategy)
	* CreateTransaction() : DbScope : DbAccessor w/transaction, IDisposable	
	* Go();

TransactionCommands
	* all accessor commands 
	* Commit()
	
Reader Commands
	* all accessor commands - "CreateTransaction"
	* IngoreResultInterceptsFor(MySchema)     
	* IngoreResultInterceptsFor(MyTable)     
	* IngoreResultInterceptsFor(MyTable.MyColumn)     
	* IngoreAllParameterIntercepts()
	* IgnoreAllResultIntercepts()
	* IgnoreAllIntercepts()	
	* As<struct>()
	* As<string>()
	* As<T...>	
	* As<T>(T)			// all return arrays.  linq to single or what-ev
	* As<T>(Func<T>)
	* As(Type)???
	* As(Func<object>)???

Writer Commands
	* all accessor commands - "CreateTransaction"
	* all reader commands - "As"
	
	
	
* MySchema & Table & Column will need to be different types
* use static MySchema.Table.Column names instead of strings, have those values not be strings so
* that no one will pass strings to those methods, they will have to use the static values.
* 
* accessor should inherit from abstract class so that this crapo has to be done in its constructor
accessor
    .RegisterResultInterceptFor(DbType).AsTransformation<bit, bool>()
	.RegisterResultInterceptFor(DbType).AsAlteration()
	.RegisterResultInterceptFor(MySchema.MyTable.MyColumn).AsTransformation<bit?, bool>(value => Bool.Parse(value))	
	.RegisterParameterInterceptFor(typeof(IEnumerable)).AsScript(e => String.Join(",", e)).ReturnEmptyWhen(e => e == null || e.Count() == 0)
	.RegisterParameterInterceptFor(typeof(DateTime)).AsAlteration(d => SqlMinDateTime)
	.RegisterParameterInterceptFor(typeof(DateTime)).AsTransformation<string>(d => SqlMinDateTime.ToString())	
	.RegisterParameterIntercept(IParameterIntercept)
	.SpecifyInsertStrategyFor(MySchema.MyTable, InsertStrategy.IdentitySelect)		// alternate: InsertStrategy.IdentityOutput
	.Go();
	
accessor.Read(
		"SELECT Type1 WHERE IN(@0)
		 SELECT Type2 ALSO WHERE
		")	
	.IngoreResultInterceptsFor(MySchema)     
	.IngoreResultInterceptsFor(MyTable)     
	.IngoreResultInterceptsFor(MyTable.MyColumn)     
	.IngoreAllParameterIntercepts()
	.IgnoreAllResultIntercepts()
	.IgnoreAllIntercepts()
	...  any intercepts here are only for this read and are overrides for other registered intercepts
	.As<T1>()	
	.As<T2>()
	.Go();
	
accessor.Write("INSERT CRAP")
	... ignores
	... overriding intercepts
	.WithStrategy(MsSql.UseScopeIdentity)
	.Go();

accessor.Write(IList<Entity>)
	... temporary ignores
	... overriding intercepts
	... overriding strategies
	.Go();
	

	
	
	
	
accessor.Read(
	@"SELECT Type1 WHERE IN(@0)"
	, 1
	, 2
	, 3)		
	.RegisterParameterIntercept(DrivenDb.EmptyEnumerableIntercept)
	.As<T>()	
	.Go();